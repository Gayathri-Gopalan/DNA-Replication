<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Replication Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            color: white;
            height: 100vh;
            display: grid;
            grid-template-areas: 
                "sidebar top-panel"
                "sidebar main-canvas"
                "sidebar bottom-panel";
            grid-template-columns: 350px 1fr;
            grid-template-rows: 80px 1fr 120px;
            overflow: hidden;
        }

        .controls-panel {
            grid-area: sidebar;
            background: rgba(30, 30, 50, 0.95);
            overflow-y: auto;
            padding: 20px;
            border-right: 3px solid #4CAF50;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }

        .top-panel {
            grid-area: top-panel;
            background: rgba(30, 30, 50, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            border-bottom: 2px solid #4CAF50;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .dna-canvas-area {
            grid-area: main-canvas;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0f0f23 100%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bottom-panel {
            grid-area: bottom-panel;
            background: rgba(30, 30, 50, 0.95);
            padding: 15px 20px;
            border-top: 2px solid #4CAF50;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
            overflow-x: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-section {
            margin-bottom: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #00BFFF;
        }

        .section-header {
            font-size: 16px;
            font-weight: bold;
            color: #00BFFF;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dna-input {
            width: 100%;
            padding: 12px;
            background: rgba(60, 80, 100, 0.8);
            border: 2px solid #555;
            border-radius: 8px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .generate-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .strand-info {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .strand-label {
            color: #FFD700;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }

        .control-btn {
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .start-btn { background: linear-gradient(45deg, #4CAF50, #45a049); }
        .stop-btn { background: linear-gradient(45deg, #f44336, #d32f2f); }
        .reset-btn { background: linear-gradient(45deg, #2196F3, #1976D2); }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .status-item {
            background: rgba(0,0,0,0.3);
            padding: 8px 6px;
            border-radius: 6px;
            text-align: center;
            font-size: 10px;
            min-height: 45px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .status-item > div:first-child {
            font-size: 9px;
            margin-bottom: 2px;
            line-height: 1.2;
        }

        .status-active { color: #4CAF50; font-weight: bold; }
        .status-inactive { color: #888; }

        .current-step {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            font-size: 12px;
            line-height: 1.4;
            color: #4CAF50;
            font-weight: bold;
            text-align: center;
        }

        .toolbox-grid {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
        }

        .tool-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: grab;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            flex: 0 0 auto;
        }

        .tool-item:hover {
            background: rgba(255,255,255,0.2);
            border-color: #4CAF50;
            transform: translateY(-2px);
        }

        .tool-item.dragging {
            cursor: grabbing;
            opacity: 0.7;
        }

        .tool-item.highlighted {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 25px rgba(76, 175, 80, 0.8); }
            100% { box-shadow: 0 0 15px rgba(76, 175, 80, 0.5); }
        }

        .tool-shape {
            margin-bottom: 4px;
        }

        .tool-label {
            font-size: 9px;
            text-align: center;
            font-weight: bold;
            color: #ccc;
            white-space: nowrap;
        }

        .nucleotide-grid {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
        }

        .nucleotide-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: grab;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            flex: 0 0 auto;
        }

        .nucleotide-item:hover {
            background: rgba(255,255,255,0.2);
            border-color: #4CAF50;
            transform: translateY(-2px);
        }

        .nucleotide-item.highlighted {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
            animation: pulse 2s infinite;
        }

        .nucleotide-shape {
            width: 26px;
            height: 26px;
            margin-bottom: 3px;
            border: 2px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #000;
            border-radius: 4px;
        }

        .nucleotide-label {
            font-size: 7px;
            text-align: center;
            font-weight: bold;
            color: #ccc;
            white-space: nowrap;
        }

        .bottom-section {
            display: flex;
            align-items: center;
            gap: 30px;
            justify-content: center;
        }

        .section-title {
            font-size: 12px;
            font-weight: bold;
            color: #00BFFF;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            text-align: center;
        }

        #canvas {
            display: block;
            background: transparent;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            width: 800px;
            height: 480px;
        }

        .sequence-length {
            color: #888;
            font-size: 11px;
            margin-top: 5px;
        }

        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.3);
        }

        .error-message.show {
            opacity: 1;
        }

        .completion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: pointer;
        }

        .completion-overlay.show {
            display: flex;
        }

        .completion-message {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(76, 175, 80, 0.3);
            cursor: pointer;
        }

        .completion-title {
            font-size: 32px;
            font-weight: bold;
            color: white;
            margin-bottom: 10px;
        }

        .completion-subtitle {
            font-size: 18px;
            color: white;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .try-again-text {
            font-size: 14px;
            color: white;
            opacity: 0.8;
            margin-top: 10px;
        }

        .title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 25px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="controls-panel">
        <div class="title">DNA Replication Lab</div>
        
        <div class="panel-section">
            <div class="section-header">DNA Sequence</div>
            <input type="text" id="dnaInput" class="dna-input" placeholder="Enter DNA sequence" maxlength="30" value="ATCGATCGATCGATCGATCGATCGATCGAT">
            <div class="sequence-length">Length: <span id="lengthDisplay">30</span> bases</div>
            <button class="generate-btn" id="generateBtn">Generate Random Sequence</button>
            
            <div class="strand-info">
                <div class="strand-label">5' → 3' Strand:</div>
                <div id="leadingStrand">ATCGATCGATCGATCGATCGATCGATCGAT</div>
            </div>
            
            <div class="strand-info">
                <div class="strand-label">3' → 5' Strand:</div>
                <div id="laggingStrand">TAGCTAGCTAGCTAGCTAGCTAGCTAGCTA</div>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-header">Current Step</div>
            <div id="currentStepInstruction" class="current-step">
                <strong>Step 1:</strong> Drag Helicase enzyme to the DNA center to begin unwinding the double helix.
            </div>
        </div>

        <div class="panel-section">
            <div class="section-header">Enzyme Status</div>
            <div class="status-grid">
                <div class="status-item">
                    <div>Helicase</div>
                    <div id="helicaseStatus" class="status-inactive">Inactive</div>
                </div>
                <div class="status-item">
                    <div>Primase</div>
                    <div id="primaseStatus" class="status-inactive">Inactive</div>
                </div>
                <div class="status-item">
                   <div>DNA Pol III</div>
                    <div id="polymeraseStatus" class="status-inactive">Inactive</div>
                </div>
                <div class="status-item">
                    <div>DNA Pol I</div>
                    <div id="polIStatus" class="status-inactive">Inactive</div>
                </div>
                <div class="status-item">
                    <div>Ligase</div>
                    <div id="ligaseStatus" class="status-inactive">Inactive</div>
                </div>
            </div>
        </div>
    </div>

    <div class="top-panel">
        <div class="control-grid">
            <button id="startBtn" class="control-btn start-btn">START</button>
            <button id="stopBtn" class="control-btn stop-btn">STOP</button>
            <button id="resetBtn" class="control-btn reset-btn">RESET</button>
        </div>
    </div>

    <div class="dna-canvas-area">
        <canvas id="canvas" width="800" height="480"></canvas>
    </div>

    <div class="bottom-panel">
        <div class="bottom-section">
            <div>
                <div class="section-title">Enzymes</div>
                <div class="toolbox-grid">
                    <div class="tool-item" data-enzyme="helicase">
                        <div class="tool-shape">
                            <svg width="24" height="24">
                                <polygon points="12,2 20,6 20,18 12,22 4,18 4,6" fill="#8D6E63" stroke="#fff" stroke-width="1.5"/>
                            </svg>
                        </div>
                        <div class="tool-label">Helicase</div>
                    </div>
                    <div class="tool-item" data-enzyme="primase">
                        <div class="tool-shape">
                            <svg width="22" height="22">
                                <circle cx="11" cy="11" r="9" fill="#00BCD4" stroke="#fff" stroke-width="1.5"/>
                            </svg>
                        </div>
                        <div class="tool-label">Primase</div>
                    </div>
                    <div class="tool-item" data-enzyme="polymerase">
                        <div class="tool-shape">
                            <svg width="24" height="24">
                                <circle cx="12" cy="12" r="10" fill="#607D8B" stroke="#fff" stroke-width="1.5"/>
                            </svg>
                        </div>
                       <div class="tool-label">DNA Pol III</div>
                    </div>
                    <div class="tool-item" data-enzyme="pol1">
                        <div class="tool-shape">
                            <svg width="22" height="22">
                                <ellipse cx="11" cy="11" rx="9" ry="8" fill="#9C27B0" stroke="#fff" stroke-width="1.5"/>
                            </svg>
                        </div>
                        <div class="tool-label">DNA Pol I</div>
                    </div>
                    <div class="tool-item" data-enzyme="ligase">
                        <div class="tool-shape">
                            <svg width="20" height="20">
                                <rect x="2" y="2" width="16" height="16" fill="#795548" stroke="#fff" stroke-width="1.5"/>
                            </svg>
                        </div>
                        <div class="tool-label">Ligase</div>
                    </div>
                </div>
            </div>
            
            <div>
                <div class="section-title">Nucleotides</div>
                <div class="nucleotide-grid">
                    <div class="nucleotide-item" data-base="A">
                        <div class="nucleotide-shape" style="background-color: #ff6b6b;">A</div>
                        <div class="nucleotide-label">Adenine</div>
                    </div>
                    <div class="nucleotide-item" data-base="T">
                        <div class="nucleotide-shape" style="background-color: #4ecdc4;">T</div>
                        <div class="nucleotide-label">Thymine</div>
                    </div>
                    <div class="nucleotide-item" data-base="G">
                        <div class="nucleotide-shape" style="background-color: #45b7d1;">G</div>
                        <div class="nucleotide-label">Guanine</div>
                    </div>
                    <div class="nucleotide-item" data-base="C">
                        <div class="nucleotide-shape" style="background-color: #96ceb4;">C</div>
                        <div class="nucleotide-label">Cytosine</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="errorMessage" class="error-message"></div>

    <div id="completionOverlay" class="completion-overlay">
        <div class="completion-message">
            <div class="completion-title">REPLICATION COMPLETED</div>
            <div class="completion-subtitle">DNA synthesis successfully finished!</div>
            <div class="try-again-text">Click anywhere to try a new simulation</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const BASE_COLORS = {
            A: '#ff6b6b',
            T: '#4ecdc4',
            G: '#45b7d1',
            C: '#96ceb4'
        };

        let gameState = {
            running: false,
            dnaSequence: 'ATCGATCGATCGATCGATCGATCGATCGAT',
            originalSequence: 'ATCGATCGATCGATCGATCGATCGATCGAT',
            dnaStrands: {
                leading: [],
                lagging: [],
                leadingNew: [],
                laggingNew: []
            },
            placedEnzymes: [],
            isDragging: false,
            draggedItem: null,
            helicaseActive: false,
            primaseActive: false,
            primaseCount: 0,
            polymeraseActive: false,
            polymeraseCount: 0,
            pol1Active: false,
            pol1Count: 0,
            ligaseActive: false,
            ligaseProcessing: false,
            dnaCenter: { x: 450, y: 300 },
            strandSeparation: 0,
            nucleotidePositions: [],
            nucleotideCount: { leading: 0, lagging: 0 },
            rnaPrimers: { leading: false, lagging: false },
            bondAnimations: [],
            laggingFragments: [
                { start: 0, end: 10, primerAdded: false, nucleotidesAdded: 0, completed: false },
                { start: 11, end: 21, primerAdded: false, nucleotidesAdded: 0, completed: false },
                { start: 22, end: 29, primerAdded: false, nucleotidesAdded: 0, completed: false }
            ],
            currentFragment: 0,
            ligaseTimer: 0,
            ligaseGapIndex: 0,
            polymerasePositions: {
                leading: -1,
                lagging: -1
            },
            gapsFixed: [],
            allGapsFixed: false
        };

        function addBondAnimation(position, strand) {
            gameState.bondAnimations.push({
                position: position,
                strand: strand,
                timer: 0,
                maxTime: 60
            });
        }

        function updateBondAnimations() {
            gameState.bondAnimations.forEach(animation => {
                animation.timer++;
            });
            gameState.bondAnimations = gameState.bondAnimations.filter(animation => {
                return animation.timer < animation.maxTime;
            });
        }

        function getBondAnimationColor(position, strand) {
            const animation = gameState.bondAnimations.find(anim => 
                anim.position === position && anim.strand === strand
            );
            
            if (!animation) return '#8B4513';
            
            const progress = animation.timer / animation.maxTime;
            if (progress < 0.2) {
                return '#FFFF00';
            } else {
                const fadeProgress = (progress - 0.2) / 0.8;
                const r = Math.round(255 + (139 - 255) * fadeProgress);
                const g = Math.round(255 + (69 - 255) * fadeProgress);
                const b = Math.round(0 + (19 - 0) * fadeProgress);
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        function getComplement(base) {
            const complements = { 'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G' };
            return complements[base] || base;
        }

        function generateRandomSequence() {
            const bases = ['A', 'T', 'G', 'C'];
            let sequence = '';
            for (let i = 0; i < 30; i++) {
                sequence += bases[Math.floor(Math.random() * bases.length)];
            }
            return sequence;
        }

        function updateDNADisplays() {
            const sequence = gameState.dnaSequence;
            const complement = sequence.split('').map(base => getComplement(base)).join('');
            
            document.getElementById('leadingStrand').textContent = sequence;
            document.getElementById('laggingStrand').textContent = complement;
            document.getElementById('lengthDisplay').textContent = sequence.length;
            
            gameState.dnaStrands.leading = sequence.split('');
            gameState.dnaStrands.lagging = complement.split('');
            gameState.dnaStrands.leadingNew = new Array(sequence.length).fill(null);
            gameState.dnaStrands.laggingNew = new Array(sequence.length).fill(null);
        }

        function updateCurrentStepInstruction() {
            const instructionElement = document.getElementById('currentStepInstruction');
            const isActive = gameState.running || gameState.placedEnzymes.length > 0;
            
            document.querySelectorAll('.tool-item, .nucleotide-item').forEach(item => {
                item.classList.remove('highlighted');
            });
            
            if (!isActive) {
                instructionElement.innerHTML = '<strong>Step 1:</strong> Click START button to begin, then drag Helicase enzyme to the DNA center to unwind the double helix.';
                instructionElement.className = 'current-step inactive';
                return;
            }
            
            instructionElement.className = 'current-step';
            
            if (!gameState.helicaseActive && gameState.placedEnzymes.filter(e => e.type === 'helicase').length === 0) {
                instructionElement.innerHTML = '<strong>Step 1:</strong> Drag Helicase enzyme to the DNA center to begin unwinding the double helix.';
                document.querySelector('[data-enzyme="helicase"]').classList.add('highlighted');
            } else if (gameState.helicaseActive && gameState.primaseCount < 2) {
                if (gameState.primaseCount === 0) {
                    instructionElement.innerHTML = '<strong>Step 2:</strong> Drag the first Primase to the 3\' end of the leading template strand (right side).';
                } else {
                    instructionElement.innerHTML = '<strong>Step 2:</strong> Drag the second Primase to the 3\' end of the lagging template strand (left side).';
                }
                document.querySelector('[data-enzyme="primase"]').classList.add('highlighted');
            } else if (gameState.polymeraseCount < 2) {
                if (!gameState.running) {
                    instructionElement.innerHTML = '<strong>Step 2.5:</strong> Click START button to activate enzymes and create RNA primers.';
                } else if (gameState.polymeraseCount === 0) {
                    instructionElement.innerHTML = '<strong>Step 3:</strong> Drag the first DNA Polymerase III near the leading strand primer.';
                } else {
                    instructionElement.innerHTML = '<strong>Step 3:</strong> Drag the second DNA Polymerase III near the lagging strand primer.';
                }
                document.querySelector('[data-enzyme="polymerase"]').classList.add('highlighted');
            } else if (!gameState.polymeraseActive) {
                instructionElement.innerHTML = '<strong>Step 3.5:</strong> Both DNA Polymerase III placed! They will activate automatically when primers are ready.';
            } else {
                const leadingTotal = gameState.dnaSequence.length - 4;
                const laggingTotal = 18;
                const leadingComplete = gameState.nucleotideCount.leading >= leadingTotal;
                const laggingManuallyComplete = gameState.nucleotideCount.lagging >= laggingTotal;
                
                if (gameState.nucleotideCount.leading + gameState.nucleotideCount.lagging === 0) {
                    instructionElement.innerHTML = '<strong>Step 4:</strong> Drag nucleotides (A, T, G, C) to empty positions. Follow base pairing rules: A-T and G-C.';
                    document.querySelectorAll('[data-base="A"], [data-base="T"], [data-base="G"], [data-base="C"]').forEach(item => {
                        item.classList.add('highlighted');
                    });
                } else if (!leadingComplete) {
                    const leadingNeeded = leadingTotal - gameState.nucleotideCount.leading;
                    instructionElement.innerHTML = '<strong>Step 4:</strong> Continue adding nucleotides to the leading strand. ' + leadingNeeded + ' bases remaining.';
                    document.querySelectorAll('[data-base="A"], [data-base="T"], [data-base="G"], [data-base="C"]').forEach(item => {
                        item.classList.add('highlighted');
                    });
                } else if (!laggingManuallyComplete) {
                    const laggingNeeded = laggingTotal - gameState.nucleotideCount.lagging;
                    instructionElement.innerHTML = '<strong>Step 4:</strong> Continue adding nucleotides to the lagging strand. ' + laggingNeeded + ' bases remaining.';
                    document.querySelectorAll('[data-base="A"], [data-base="T"], [data-base="G"], [data-base="C"]').forEach(item => {
                        item.classList.add('highlighted');
                    });
                } else if (gameState.pol1Count === 0) {
                    instructionElement.innerHTML = '<strong>Step 5:</strong> All nucleotides added! Drag DNA Polymerase I to automatically replace ALL RNA primers with DNA.';
                    document.querySelector('[data-enzyme="pol1"]').classList.add('highlighted');
                } else if (!gameState.pol1Active) {
                    instructionElement.innerHTML = '<strong>Step 5.5:</strong> DNA Polymerase I placed! It will automatically replace all RNA primers with DNA bases.';
                } else if (!gameState.ligaseActive) {
                    instructionElement.innerHTML = '<strong>Step 6:</strong> All RNA primers replaced with DNA! Drag DNA Ligase to join all Okazaki fragments.';
                    document.querySelector('[data-enzyme="ligase"]').classList.add('highlighted');
                } else if (gameState.ligaseProcessing) {
                    instructionElement.innerHTML = '<strong>Step 6 In Progress:</strong> DNA Ligase is actively joining Okazaki fragments...';
                } else {
                    instructionElement.innerHTML = '<strong>Complete!</strong> DNA replication finished! All fragments joined.';
                }
            }
        }

        function updateStatusDisplay() {
            document.getElementById('helicaseStatus').textContent = gameState.helicaseActive ? 'Active' : 'Inactive';
            document.getElementById('helicaseStatus').className = gameState.helicaseActive ? 'status-active' : 'status-inactive';
            
            document.getElementById('primaseStatus').textContent = gameState.primaseActive ? 'Active' : 'Inactive';
            document.getElementById('primaseStatus').className = gameState.primaseActive ? 'status-active' : 'status-inactive';
            
            document.getElementById('polymeraseStatus').textContent = gameState.polymeraseActive ? 'Active' : 'Inactive';
            document.getElementById('polymeraseStatus').className = gameState.polymeraseActive ? 'status-active' : 'status-inactive';
            
            document.getElementById('polIStatus').textContent = gameState.pol1Active ? 'Active' : 'Inactive';
            document.getElementById('polIStatus').className = gameState.pol1Active ? 'status-active' : 'status-inactive';
            
            document.getElementById('ligaseStatus').textContent = gameState.ligaseActive ? 'Active' : 'Inactive';
            document.getElementById('ligaseStatus').className = gameState.ligaseActive ? 'status-active' : 'status-inactive';
            
            updateCurrentStepInstruction();
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => {
                errorDiv.classList.remove('show');
            }, 4000);
        }

        function canPlaceEnzyme(enzymeType) {
            switch (enzymeType) {
                case 'helicase':
                    return gameState.placedEnzymes.filter(e => e.type === 'helicase').length === 0;
                case 'primase':
                    return gameState.helicaseActive && gameState.primaseCount < 2;
                case 'polymerase':
                    return gameState.primaseCount >= 2 && gameState.polymeraseCount < 2;
                case 'pol1':
                    const leadingComplete = gameState.nucleotideCount.leading >= gameState.dnaSequence.length - 4;
                    const laggingComplete = gameState.nucleotideCount.lagging >= 18;
                    return gameState.polymeraseCount >= 2 && leadingComplete && laggingComplete && gameState.pol1Count === 0;
                case 'ligase':
                    return gameState.pol1Active && !gameState.ligaseActive;
                default:
                    return false;
            }
        }

        function processLigaseActivity() {
            if (!gameState.ligaseActive || !gameState.running || !gameState.ligaseProcessing) return;
            
            gameState.ligaseTimer++;
            
            // Fix gaps progressively
            if (gameState.ligaseTimer === 60) {
                // Fix first gap
                gameState.gapsFixed.push(11);
                showError('DNA Ligase joined fragments 1 and 2!');
            } else if (gameState.ligaseTimer === 120) {
                // Fix second gap
                gameState.gapsFixed.push(22);
                showError('DNA Ligase joined fragments 2 and 3!');
            }
            
            if (gameState.ligaseTimer >= 180) {
                const ligaseIndex = gameState.placedEnzymes.findIndex(e => e.type === 'ligase');
                if (ligaseIndex !== -1) {
                    gameState.placedEnzymes.splice(ligaseIndex, 1);
                }
                
                gameState.ligaseProcessing = false;
                gameState.allGapsFixed = true;
                showError('DNA Ligase completed joining all fragments and detached! All enzymes have finished their work.');
                
                setTimeout(() => {
                    document.getElementById('completionOverlay').classList.add('show');
                }, 5000);
            }
        }

        function drawDNA() {
            const sequence = gameState.dnaSequence;
            const baseWidth = Math.min(26, (canvas.width - 200) / sequence.length);
            const startX = canvas.width / 2 - (sequence.length * baseWidth / 2);
            const leadingY = canvas.height / 2 - 80 - gameState.strandSeparation;
            const laggingY = canvas.height / 2 + 80 + gameState.strandSeparation;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f0f23';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Template strand labels
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("5'", startX - 60, leadingY + 6);
            ctx.fillText("3'", startX + sequence.length * baseWidth + 50, leadingY + 6);
            ctx.fillText("3'", startX - 60, laggingY + 6);
            ctx.fillText("5'", startX + sequence.length * baseWidth + 50, laggingY + 6);

            // Draw template strand backbones
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(startX - 40, leadingY - 11 - 3);
            ctx.lineTo(startX + sequence.length * baseWidth + 40, leadingY - 11 - 3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(startX - 40, laggingY + 11 + 3);
            ctx.lineTo(startX + sequence.length * baseWidth + 40, laggingY + 11 + 3);
            ctx.stroke();

            // Draw template bases
            for (let i = 0; i < sequence.length; i++) {
                const x = startX + i * baseWidth;
                const boxSize = 22;
                
                const leadingBase = gameState.dnaStrands.leading[i];
                ctx.fillStyle = BASE_COLORS[leadingBase];
                ctx.fillRect(x - boxSize/2, leadingY - boxSize/2, boxSize, boxSize);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - boxSize/2, leadingY - boxSize/2, boxSize, boxSize);
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(leadingBase, x, leadingY + 4);

                const laggingBase = gameState.dnaStrands.lagging[i];
                ctx.fillStyle = BASE_COLORS[laggingBase];
                ctx.fillRect(x - boxSize/2, laggingY - boxSize/2, boxSize, boxSize);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - boxSize/2, laggingY - boxSize/2, boxSize, boxSize);
                ctx.fillStyle = '#000';
                ctx.fillText(laggingBase, x, laggingY + 4);

                if (gameState.strandSeparation < 50) {
                    ctx.strokeStyle = '#87CEEB';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.moveTo(x, leadingY + boxSize/2);
                    ctx.lineTo(x, laggingY - boxSize/2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw RNA primers (only show if Pol I hasn't replaced them yet)
            if (!gameState.pol1Active && (gameState.rnaPrimers.leading || gameState.rnaPrimers.lagging)) {
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                        
                // Leading strand RNA primer
                if (gameState.rnaPrimers.leading) {
                    const primerY = leadingY + 45;
                    const templateBases = gameState.dnaStrands.leading.slice(-4);
                    const primerBases = templateBases.map(base => {
                        const complement = { 'A': 'U', 'T': 'A', 'G': 'C', 'C': 'G' };
                        return complement[base];
                    });
                            
                    for (let i = 0; i < primerBases.length; i++) {
                        const templateIndex = sequence.length - 4 + i;
                        const primerX = startX + templateIndex * baseWidth;
                        
                        ctx.fillStyle = '#90EE90';
                        ctx.fillRect(primerX - 10, primerY - 10, 20, 20);
                        ctx.strokeStyle = '#228B22';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(primerX - 10, primerY - 10, 20, 20);
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 10px Arial';
                        ctx.fillText(primerBases[i], primerX, primerY + 3);
                        
                        if (i > 0) {
                            const prevPrimerX = startX + (sequence.length - 4 + i - 1) * baseWidth;
                            ctx.strokeStyle = '#228B22';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(prevPrimerX + 10, primerY);
                            ctx.lineTo(primerX - 10, primerY);
                            ctx.stroke();
                        }
                        
                        ctx.strokeStyle = '#87CEEB';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(primerX, primerY - 10);
                        ctx.lineTo(primerX, leadingY + 11);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText("5'", startX + sequence.length * baseWidth + 25, primerY + 4);
                    
                    ctx.fillStyle = '#228B22';
                    ctx.font = 'bold 9px Arial';
                    ctx.fillText('RNA Primer', startX + (sequence.length - 2) * baseWidth, primerY - 20);
                }
                
                // Lagging strand RNA primer - first fragment
                if (gameState.rnaPrimers.lagging) {
                    const primerY = laggingY - 45;
                    const templateBases = gameState.dnaStrands.lagging.slice(0, 4);
                    const primerBases = templateBases.map(base => {
                        const complement = { 'A': 'U', 'T': 'A', 'G': 'C', 'C': 'G' };
                        return complement[base];
                    });
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText("5'", startX - 25, primerY + 4);
                    
                    for (let i = 0; i < primerBases.length; i++) {
                        const primerX = startX + i * baseWidth;
                        
                        ctx.fillStyle = '#90EE90';
                        ctx.fillRect(primerX - 10, primerY - 10, 20, 20);
                        ctx.strokeStyle = '#228B22';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(primerX - 10, primerY - 10, 20, 20);
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 10px Arial';
                        ctx.fillText(primerBases[i], primerX, primerY + 3);

                        if (i > 0) {
                            const prevPrimerX = startX + (i - 1) * baseWidth;
                            ctx.strokeStyle = '#228B22';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(prevPrimerX + 10, primerY);
                            ctx.lineTo(primerX - 10, primerY);
                            ctx.stroke();
                        }
                        
                        ctx.strokeStyle = '#87CEEB';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(primerX, primerY + 10);
                        ctx.lineTo(primerX, laggingY - 11);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    ctx.fillStyle = '#228B22';
                    ctx.font = 'bold 9px Arial';
                    ctx.fillText('RNA Primer', startX + 2 * baseWidth, primerY + 20);
                }

                // Draw RNA primers for additional lagging fragments
                gameState.laggingFragments.forEach((fragment, index) => {
                    if (fragment.primerAdded && index > 0) {
                        const fragmentStartX = startX + fragment.start * baseWidth;
                        const primerY = laggingY - 45;
                        
                        const templateBases = gameState.dnaStrands.lagging.slice(fragment.start, fragment.start + 4);
                        const primerBases = templateBases.map(base => {
                            const complement = { 'A': 'U', 'T': 'A', 'G': 'C', 'C': 'G' };
                            return complement[base];
                        });
                        
                        for (let i = 0; i < primerBases.length; i++) {
                            const primerX = fragmentStartX + i * baseWidth;
                            
                            ctx.fillStyle = '#90EE90';
                            ctx.fillRect(primerX - 10, primerY - 10, 20, 20);
                            ctx.strokeStyle = '#228B22';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(primerX - 10, primerY - 10, 20, 20);
                            ctx.fillStyle = '#000';
                            ctx.font = 'bold 10px Arial';
                            ctx.fillText(primerBases[i], primerX, primerY + 3);

                            if (i > 0) {
                                const prevPrimerX = fragmentStartX + (i - 1) * baseWidth;
                                ctx.strokeStyle = '#228B22';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(prevPrimerX + 10, primerY);
                                ctx.lineTo(primerX - 10, primerY);
                                ctx.stroke();
                            }
                            
                            ctx.strokeStyle = '#87CEEB';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([4, 4]);
                            ctx.beginPath();
                            ctx.moveTo(primerX, primerY + 10);
                            ctx.lineTo(primerX, laggingY - 11);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        
                        ctx.fillStyle = '#228B22';
                        ctx.font = 'bold 9px Arial';
                        ctx.fillText('RNA Primer', fragmentStartX + 2 * baseWidth, primerY + 20);
                    }
                });
            }

            // Draw newly synthesized nucleotides
            const boxSize = 22;
            
            // Leading strand synthesis
            if (gameState.polymeraseActive || gameState.pol1Active) {
                // Find the extent of synthesized leading strand
                let leadingStart = -1, leadingEnd = -1;
                for (let i = 0; i < sequence.length; i++) {
                    if (gameState.dnaStrands.leadingNew[i]) {
                        if (leadingStart === -1) leadingStart = i;
                        leadingEnd = i;
                    }
                }
                
                // Draw leading strand labels for newly synthesized DNA
                if (leadingStart !== -1 && gameState.nucleotideCount.leading > 0) {
                    const newY = leadingY + 45;
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    
                    // Show 3' end label at the leftmost DNA nucleotide position (not primer position)
                    let leftmostDNA = -1;
                    for (let i = 0; i < sequence.length; i++) {
                        if (gameState.dnaStrands.leadingNew[i] && (!gameState.pol1Active || i < sequence.length - 4)) {
                            leftmostDNA = i;
                            break;
                        }
                    }
                    
                    if (leftmostDNA !== -1) {
                        ctx.fillText("3'", startX + leftmostDNA * baseWidth - 25, newY + 4);
                    }
                    
                    // Show 5' end at rightmost position when RNA primers are replaced with DNA (Pol I active)
                    if (gameState.pol1Active) {
                        ctx.fillText("5'", startX + leadingEnd * baseWidth + 25, newY + 4);
                    }
                }
                
                for (let i = sequence.length - 1; i >= 0; i--) {
                    const x = startX + i * baseWidth;
                    const newY = leadingY + 45;
                    
                    if (gameState.dnaStrands.leadingNew[i]) {
                        const newBase = gameState.dnaStrands.leadingNew[i];
                        
                        ctx.fillStyle = BASE_COLORS[newBase];
                        ctx.fillRect(x - boxSize/2, newY - boxSize/2, boxSize, boxSize);
                        
                        if (gameState.pol1Active && i >= sequence.length - 4) {
                            ctx.strokeStyle = '#9C27B0';
                            ctx.lineWidth = 4;
                        } else {
                            ctx.strokeStyle = '#FFFF00';
                            ctx.lineWidth = 3;
                        }
                        ctx.strokeRect(x - boxSize/2, newY - boxSize/2, boxSize, boxSize);
                        
                        ctx.fillStyle = '#000000';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(newBase, x, newY + 4);

                        ctx.strokeStyle = '#00FF00';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(x, newY - boxSize/2);
                        ctx.lineTo(x, leadingY + boxSize/2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
                
                // Draw leading strand backbone as horizontal brown line
                let leadingBackboneStart = -1, leadingBackboneEnd = -1;
                for (let i = 0; i < sequence.length; i++) {
                    if (gameState.dnaStrands.leadingNew[i]) {
                        if (leadingBackboneStart === -1) leadingBackboneStart = i;
                        leadingBackboneEnd = i;
                    }
                }
                
                if (leadingBackboneStart !== -1 && leadingBackboneEnd !== -1) {
                    const newY = leadingY + 45;
                    ctx.strokeStyle = '#8B4513'; // Brown color like template strands
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(startX + leadingBackboneStart * baseWidth - boxSize/2, newY + boxSize/2 - 2);
                    ctx.lineTo(startX + leadingBackboneEnd * baseWidth + boxSize/2, newY + boxSize/2 - 2);
                    ctx.stroke();
                    
                    // Draw bond animations on top of backbone
                    for (let i = 0; i < sequence.length - 1; i++) {
                        const x = startX + i * baseWidth;
                        const nextX = startX + (i + 1) * baseWidth;
                        
                        if (gameState.dnaStrands.leadingNew[i] && gameState.dnaStrands.leadingNew[i + 1]) {
                            const bondColor = getBondAnimationColor(i, 'leading');
                            if (bondColor !== '#8B4513' && !(gameState.gapsFixed && gameState.gapsFixed.includes(i))) { // Only draw if there's an animation
                                ctx.strokeStyle = bondColor;
                                ctx.lineWidth = 8;
                                ctx.beginPath();
                                ctx.moveTo(x + boxSize/2, newY + boxSize/2 - 2);
                                ctx.lineTo(nextX - boxSize/2, newY + boxSize/2 - 2);
                                ctx.stroke();
                            }
                        }
                    }
                }
            }

            // Lagging strand synthesis
            if (gameState.polymeraseActive || gameState.ligaseActive) {
                const newY = laggingY - 45;
                
                // Draw lagging strand labels for newly synthesized DNA
                let laggingStart = -1, laggingEnd = -1;
                for (let i = 0; i < sequence.length; i++) {
                    if (gameState.dnaStrands.laggingNew[i]) {
                        if (laggingStart === -1) laggingStart = i;
                        laggingEnd = i;
                    }
                }

                if (laggingStart !== -1 && gameState.nucleotideCount.lagging > 0) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    
                    // Show 3' end at rightmost position
                    ctx.fillText("3'", startX + laggingEnd * baseWidth + 25, newY + 4);
                    
                    // Show 5' end at leftmost position when RNA primers are replaced with DNA (Pol I active)
                    if (gameState.pol1Active) {
                        ctx.fillText("5'", startX + laggingStart * baseWidth - 25, newY + 4);
                    }
                }
                
                // Draw all lagging strand bases first
                for (let i = 0; i < sequence.length; i++) {
                    const x = startX + i * baseWidth;
                    
                    if (gameState.dnaStrands.laggingNew[i]) {
                        const newBase = gameState.dnaStrands.laggingNew[i];
                        
                        ctx.fillStyle = BASE_COLORS[newBase];
                        ctx.fillRect(x - boxSize/2, newY - boxSize/2, boxSize, boxSize);
                        
                        let isPol1Primer = false;
                        
                        if (gameState.pol1Active) {
                            const primerPositions = [
                                [0, 1, 2, 3], [11, 12, 13, 14], 
                                [22, 23, 24, 25]
                            ];
                            for (let positions of primerPositions) {
                                if (positions.includes(i)) {
                                    isPol1Primer = true;
                                    break;
                                }
                            }
                        }
                        
                        if (isPol1Primer) {
                            ctx.strokeStyle = '#9C27B0';
                            ctx.lineWidth = 4;
                        } else {
                            ctx.strokeStyle = '#FFFFFF';
                            ctx.lineWidth = 3;
                        }
                        ctx.strokeRect(x - boxSize/2, newY - boxSize/2, boxSize, boxSize);
                        
                        ctx.fillStyle = '#000000';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(newBase, x, newY + 4);

                        ctx.strokeStyle = '#00FF00';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(x, newY + boxSize/2);
                        ctx.lineTo(x, laggingY - boxSize/2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                // Draw lagging strand backbone as horizontal brown line
                let laggingBackboneStart = -1, laggingBackboneEnd = -1;
                for (let i = 0; i < sequence.length; i++) {
                    if (gameState.dnaStrands.laggingNew[i]) {
                        if (laggingBackboneStart === -1) laggingBackboneStart = i;
                        laggingBackboneEnd = i;
                    }
                }
                
                if (laggingBackboneStart !== -1 && laggingBackboneEnd !== -1) {
    ctx.strokeStyle = '#8B4513'; // Brown color like template strands
    ctx.lineWidth = 6;
    
    if (gameState.pol1Active) {
        // After Pol I: draw full horizontal brown line
        ctx.beginPath();
        ctx.moveTo(startX + laggingBackboneStart * baseWidth - boxSize/2, newY - boxSize/2 + 2);
        ctx.lineTo(startX + laggingBackboneEnd * baseWidth + boxSize/2, newY - boxSize/2 + 2);
        ctx.stroke();
    } else {
        // Before Pol I: draw brown line for each individual nucleotide (like leading strand)
        for (let i = 0; i < sequence.length; i++) {
            if (gameState.dnaStrands.laggingNew[i]) {
                // Draw backbone segment for each nucleotide
                ctx.beginPath();
                ctx.moveTo(startX + i * baseWidth - boxSize/2, newY - boxSize/2 + 2);
                ctx.lineTo(startX + i * baseWidth + boxSize/2, newY - boxSize/2 + 2);
                ctx.stroke();
            }
        }
    }
                    
                    // Draw gaps and bond animations on top of backbone
                    for (let i = 1; i < sequence.length; i++) {
                        const x = startX + i * baseWidth;
                        const prevX = startX + (i - 1) * baseWidth;
                        
                        if (gameState.dnaStrands.laggingNew[i] && gameState.dnaStrands.laggingNew[i - 1]) {
                            let shouldDrawBackbone = true;
                            let isGapFixed = false;

                            if (gameState.pol1Active) {
                                if (i === 11 || i === 22) {
                                    shouldDrawBackbone = false;
                                    // Check if this gap has been fixed by ligase
                                    if (gameState.gapsFixed && gameState.gapsFixed.includes(i)) {
                                        isGapFixed = true;
                                        shouldDrawBackbone = true;
                                    }
                                }
                            }

                            if (!shouldDrawBackbone && !isGapFixed) {
                                // Show gap visually with bright orange dashed line and highlight
                                ctx.strokeStyle = '#FF8C00';
                                ctx.lineWidth = 6;
                                ctx.setLineDash([6, 6]);
                                ctx.beginPath();
                                ctx.moveTo(prevX + boxSize/2, newY - boxSize/2 + 2);
                                ctx.lineTo(x - boxSize/2, newY - boxSize/2 + 2);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Add gap highlight circle
                                ctx.strokeStyle = '#FF4500';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.arc((prevX + x) / 2, newY - boxSize/2 + 2, 15, 0, Math.PI * 2);
                                ctx.stroke();
                                
                                // Add "GAP" text
                                ctx.fillStyle = '#FFFF00';
                                ctx.font = 'bold 8px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('GAP', (prevX + x) / 2, newY + 25);
                            } else {
                                let bondColor = getBondAnimationColor(i - 1, 'lagging');
                                
                                if (gameState.ligaseActive && (i === 11 || i === 22)) {
    if (gameState.gapsFixed && gameState.gapsFixed.includes(i)) {
        // Gap is fixed - don't draw any vertical line at all
        continue; // Skip drawing this bond entirely
    } else {
        bondColor = '#FFFF00'; // Yellow for active ligase activity
    }
}
                                
                                // Only draw if there's an animation or ligase activity
                                if (bondColor !== '#8B4513') {
                                    ctx.strokeStyle = bondColor;
                                    ctx.lineWidth = 8;
                                    ctx.beginPath();
                                    ctx.moveTo(prevX + boxSize/2, newY - boxSize/2 + 2);
                                    ctx.lineTo(x - boxSize/2, newY - boxSize/2 + 2);
                                    ctx.stroke();
                                }
                            }
                        }
                    }
                }
            }
            
            gameState.nucleotidePositions = [];
            
            // Leading strand positions
            if (gameState.polymeraseActive && !gameState.ligaseProcessing) {
                for (let i = sequence.length - 5; i >= 0; i--) {
                    if (!gameState.dnaStrands.leadingNew[i]) {
                        if (i === sequence.length - 5 || gameState.dnaStrands.leadingNew[i + 1]) {
                            const x = startX + i * baseWidth;
                            gameState.nucleotidePositions.push({
                                x: x, 
                                y: leadingY + 45,
                                width: boxSize, 
                                height: boxSize, 
                                strand: 'leading', 
                                index: i
                            });
                            break;
                        }
                    }
                }
            }
            
            // Lagging strand positions - show only the next position to add nucleotide
            if (gameState.polymeraseActive && !gameState.ligaseProcessing) {
                const currentFragment = gameState.laggingFragments[gameState.currentFragment];
                if (currentFragment && currentFragment.primerAdded) {
                    let nextPosition = -1;
                    
                    if (gameState.currentFragment === 0) {
                        // First fragment: find next empty position from 4-10
                        for (let i = 4; i <= 10; i++) {
                            if (!gameState.dnaStrands.laggingNew[i]) {
                                nextPosition = i;
                                break;
                            }
                        }
                    } else if (gameState.currentFragment === 1) {
                        // Second fragment: find next empty position from 15-21
                        for (let i = 15; i <= 21; i++) {
                            if (!gameState.dnaStrands.laggingNew[i]) {
                                nextPosition = i;
                                break;
                            }
                        }
                    } else if (gameState.currentFragment === 2) {
                        // Third fragment: find next empty position from 26-29
                        for (let i = 26; i <= 29; i++) {
                            if (!gameState.dnaStrands.laggingNew[i]) {
                                nextPosition = i;
                                break;
                            }
                        }
                    }
                    
                    // Only add one position - where the next nucleotide should go
                    if (nextPosition !== -1) {
                        const x = startX + nextPosition * baseWidth;
                        gameState.nucleotidePositions.push({
                            x: x, 
                            y: laggingY - 45,
                            width: boxSize, 
                            height: boxSize, 
                            strand: 'lagging', 
                            index: nextPosition
                        });
                    }
                }
            }
        }

        function drawPlacedEnzymes() {
            gameState.placedEnzymes.forEach(enzyme => {
                drawEnzyme(enzyme.x, enzyme.y, enzyme.type, enzyme.active);
            });
        }

        function drawEnzyme(x, y, type, active) {
            ctx.save();
            ctx.translate(x, y);

            if (active) {
                ctx.shadowColor = '#4CAF50';
                ctx.shadowBlur = 15;
            }

            switch (type) {
                case 'helicase':
                    ctx.fillStyle = '#8D6E63';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI) / 3;
                        const px = Math.cos(angle) * 20;
                        const py = Math.sin(angle) * 20;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'primase':
                    ctx.fillStyle = '#00BCD4';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'polymerase':
                    ctx.fillStyle = 'rgba(96, 125, 139, 0.4)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 18, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'pol1':
                    ctx.fillStyle = '#9C27B0';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 15, 13, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'ligase':
                    ctx.fillStyle = '#795548';
                    ctx.fillRect(-12, -12, 24, 24);
                    break;
            }

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowBlur = 0;

            if (active) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 3;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(type.charAt(0).toUpperCase() + type.slice(1), 0, 35);

            ctx.restore();
        }

        function updateReplication() {
            if (!gameState.running) return;

            updateBondAnimations();

            const helicase = gameState.placedEnzymes.find(e => e.type === 'helicase');
            if (helicase && !gameState.helicaseActive && gameState.running) {
                gameState.helicaseActive = true;
                helicase.active = true;
                updateCurrentStepInstruction();
            }

            if (gameState.helicaseActive && gameState.strandSeparation < 80) {
                gameState.strandSeparation += 1.5;
            }

            if (gameState.helicaseActive && gameState.strandSeparation >= 80) {
                const helicaseIndex = gameState.placedEnzymes.findIndex(e => e.type === 'helicase');
                if (helicaseIndex !== -1) {
                    gameState.placedEnzymes.splice(helicaseIndex, 1);
                    showError('Helicase completed unwinding and moved away from the replication fork!');
                }
            }

            const primases = gameState.placedEnzymes.filter(e => e.type === 'primase');
            if (primases.length >= 2 && gameState.helicaseActive && gameState.strandSeparation > 40 && !gameState.primaseActive && gameState.running) {
                gameState.primaseActive = true;
                primases.forEach(p => p.active = true);
                gameState.rnaPrimers.leading = true;
                gameState.rnaPrimers.lagging = true;
                gameState.laggingFragments[0].primerAdded = true;
                updateCurrentStepInstruction();
                
                setTimeout(() => {
                    gameState.placedEnzymes = gameState.placedEnzymes.filter(e => e.type !== 'primase');
                    showError('Primases completed RNA primer synthesis and detached!');
                }, 2000);
            }

            const polymerases = gameState.placedEnzymes.filter(e => e.type === 'polymerase');
            if (polymerases.length >= 2 && gameState.primaseActive && !gameState.polymeraseActive && gameState.running) {
                gameState.polymeraseActive = true;
                polymerases.forEach(p => p.active = true);
                updateCurrentStepInstruction();
            }

            const leadingComplete = gameState.nucleotideCount.leading >= gameState.dnaSequence.length - 4;
            const laggingComplete = gameState.nucleotideCount.lagging >= 18;
            if (gameState.polymeraseActive && leadingComplete && laggingComplete && polymerases.length > 0) {
                gameState.placedEnzymes = gameState.placedEnzymes.filter(e => e.type !== 'polymerase');
                showError('DNA Polymerase III completed synthesis and detached from both strands!');
            }

            const pol1 = gameState.placedEnzymes.find(e => e.type === 'pol1');
            if (pol1 && leadingComplete && laggingComplete && !gameState.pol1Active && gameState.running) {
                gameState.pol1Active = true;
                pol1.active = true;
                
                for (let i = gameState.dnaSequence.length - 4; i < gameState.dnaSequence.length; i++) {
                    const templateBase = gameState.dnaStrands.leading[i];
                    const complement = getComplement(templateBase);
                    gameState.dnaStrands.leadingNew[i] = complement;
                }
                
                const laggingPrimerPositions = [
                    [0, 1, 2, 3],
                    [11, 12, 13, 14],
                    [22, 23, 24, 25]
                ];
                
                laggingPrimerPositions.forEach((positions) => {
                    positions.forEach(i => {
                        const templateBase = gameState.dnaStrands.lagging[i];
                        const complement = getComplement(templateBase);
                        gameState.dnaStrands.laggingNew[i] = complement;
                    });
                });
                
                showError('DNA Polymerase I automatically replaced ALL RNA primers with DNA bases!');
                
                setTimeout(() => {
                    const pol1Index = gameState.placedEnzymes.findIndex(e => e.type === 'pol1');
                    if (pol1Index !== -1) {
                        gameState.placedEnzymes.splice(pol1Index, 1);
                        showError('DNA Polymerase I completed primer replacement and detached!');
                    }
                }, 3000);
            }

            const ligase = gameState.placedEnzymes.find(e => e.type === 'ligase');
            if (ligase && gameState.pol1Active && !gameState.ligaseActive && gameState.running) {
                gameState.ligaseActive = true;
                ligase.active = true;
                gameState.ligaseProcessing = true;
                gameState.ligaseTimer = 0;
                gameState.ligaseGapIndex = 0;
                
                showError('DNA Ligase activated! Beginning to join Okazaki fragments...');
            }

            processLigaseActivity();
            updateStatusDisplay();
        }

        function render() {
            try {
                ctx.save();
                drawDNA();
                drawPlacedEnzymes();
                updateReplication();
                updateBondAnimations();
                updateCurrentStepInstruction();

                if (gameState.isDragging && gameState.draggedItem) {
                    const item = gameState.draggedItem;
                    if (item.type === 'enzyme') {
                        drawEnzyme(item.x, item.y, item.enzyme);
                    } else if (item.type === 'nucleotide') {
                        ctx.fillStyle = BASE_COLORS[item.base];
                        ctx.fillRect(item.x - 12, item.y - 10, 24, 20);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(item.x - 12, item.y - 10, 24, 20);
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(item.base, item.x, item.y + 5);
                    }
                }
                
                ctx.restore();
            } catch (error) {
                console.error('Rendering error:', error);
            }
            
            requestAnimationFrame(render);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function getNucleotideClickPosition(mousePos) {
            for (let i = 0; i < gameState.nucleotidePositions.length; i++) {
                const pos = gameState.nucleotidePositions[i];
                
                if (mousePos.x >= pos.x - pos.width/2 && 
                    mousePos.x <= pos.x + pos.width/2 &&
                    mousePos.y >= pos.y - pos.height/2 && 
                    mousePos.y <= pos.y + pos.height/2) {
                    return { strand: pos.strand, index: pos.index };
                }
            }
            return null;
        }

        function isValidNucleotidePlacement(base, strandType, position) {
            const originalBase = strandType === 'leading' 
                ? gameState.dnaStrands.leading[position]
                : gameState.dnaStrands.lagging[position];
            
            const expectedBase = getComplement(originalBase);
            return base === expectedBase;
        }

        // Event listeners and remaining code
        canvas.addEventListener('mousemove', (e) => {
            if (gameState.isDragging && gameState.draggedItem) {
                const mousePos = getMousePos(e);
                gameState.draggedItem.x = mousePos.x;
                gameState.draggedItem.y = mousePos.y;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState.isDragging && gameState.draggedItem) {
                const item = gameState.draggedItem;
                const mousePos = getMousePos(e);
                
                if (item.type === 'enzyme') {
                    if (!canPlaceEnzyme(item.enzyme)) {
                        let errorMessage = '';
                        switch (item.enzyme) {
                            case 'helicase':
                                errorMessage = 'Only one Helicase allowed!';
                                break;
                            case 'primase':
                                if (!gameState.helicaseActive) {
                                    errorMessage = 'Place Helicase first to unwind DNA!';
                                } else {
                                    errorMessage = 'Maximum 2 Primases (one for each 3\' end)!';
                                }
                                break;
                            case 'polymerase':
                                if (gameState.primaseCount < 2) {
                                    errorMessage = 'Place both Primases first (at 3\' ends)!';
                                } else {
                                    errorMessage = 'Maximum 2 DNA Polymerase III (one for each strand)!';
                                }
                                break;
                            case 'pol1':
                                if (gameState.polymeraseCount < 2) {
                                    errorMessage = 'Place both DNA Polymerase III first!';
                                } else {
                                    errorMessage = 'Complete nucleotide addition first, then place DNA Polymerase I!';
                                }
                                break;
                            case 'ligase':
                                if (!gameState.pol1Active) {
                                    errorMessage = 'Place DNA Polymerase I first to replace RNA primers!';
                                } else {
                                    errorMessage = 'DNA Ligase already placed!';
                                }
                                break;
                        }
                        showError(errorMessage);
                    } else {
                        const baseWidth = Math.min(26, (canvas.width - 200) / gameState.dnaSequence.length);
                        const startX = canvas.width / 2 - (gameState.dnaSequence.length * baseWidth / 2);
                        
                        let enzymeX, enzymeY;
                        switch (item.enzyme) {
                            case 'helicase':
                                enzymeX = canvas.width / 2;
                                enzymeY = canvas.height / 2;
                                break;
                            case 'primase':
                                if (gameState.primaseCount === 0) {
                                    enzymeX = startX + gameState.dnaSequence.length * baseWidth + 40;
                                    enzymeY = canvas.height / 2 - 80 - gameState.strandSeparation;
                                } else {
                                    enzymeX = startX - 40;
                                    enzymeY = canvas.height / 2 + 80 + gameState.strandSeparation;
                                }
                                gameState.primaseCount++;
                                break;
                            case 'polymerase':
                                if (gameState.polymeraseCount === 0) {
                                    enzymeX = startX + (gameState.dnaSequence.length - 5) * baseWidth;
                                    enzymeY = canvas.height / 2 - 80 - gameState.strandSeparation;
                                    gameState.polymerasePositions.leading = gameState.dnaSequence.length - 5;
                                } else {
                                    enzymeX = startX + 4 * baseWidth;
                                    enzymeY = canvas.height / 2 + 80 + gameState.strandSeparation;
                                    gameState.polymerasePositions.lagging = 4;
                                }
                                gameState.polymeraseCount++;
                                break;
                            case 'pol1':
                                enzymeX = canvas.width / 2 - 100;
                                enzymeY = canvas.height / 2;
                                gameState.pol1Count++;
                                break;
                            case 'ligase':
                                enzymeX = canvas.width / 2;
                                enzymeY = canvas.height / 2;
                                break;
                            default:
                                enzymeX = item.x;
                                enzymeY = item.y;
                        }

                        gameState.placedEnzymes.push({
                            type: item.enzyme,
                            x: enzymeX,
                            y: enzymeY,
                            active: false
                        });
                        
                        switch (item.enzyme) {
                            case 'helicase':
                                showError('Step 1 Complete: Helicase placed! DNA strands will unwind when simulation starts.');
                                break;
                            case 'primase':
                                if (gameState.primaseCount === 1) {
                                    showError('First Primase placed! Add one more Primase to complete step 2.');
                                } else {
                                    showError('Step 2 Complete: Both Primases placed! RNA primers will be synthesized.');
                                }
                                break;
                            case 'polymerase':
                                if (gameState.polymeraseCount === 1) {
                                    showError('First DNA Polymerase III placed! Add one more to complete step 3.');
                                } else {
                                    showError('Step 3 Complete: Both DNA Polymerase III placed! Ready for nucleotide addition.');
                                }
                                break;
                            case 'pol1':
                                showError('Step 5 Complete: DNA Polymerase I placed! RNA primers will be replaced with DNA bases.');
                                break;
                            case 'ligase':
                                showError('Step 6 Complete: DNA Ligase placed! Fragments will be joined.');
                                break;
                        }
                        updateCurrentStepInstruction();
                    }
                } else if (item.type === 'nucleotide') {
                    const clickPos = getNucleotideClickPosition(mousePos);
                    
                    if (clickPos && gameState.polymeraseActive && !gameState.ligaseProcessing) {
                        const strandArray = clickPos.strand === 'leading' ? 
                            gameState.dnaStrands.leadingNew : gameState.dnaStrands.laggingNew;
                        
                        if (strandArray[clickPos.index] === null) {
                            if (isValidNucleotidePlacement(item.base, clickPos.strand, clickPos.index)) {
                                strandArray[clickPos.index] = item.base;
                                gameState.nucleotideCount[clickPos.strand]++;
                                
                                if (clickPos.strand === 'leading') {
                                    if (clickPos.index < gameState.dnaSequence.length - 1 && gameState.dnaStrands.leadingNew[clickPos.index + 1]) {
                                        addBondAnimation(clickPos.index, 'leading');
                                        showError('Phosphodiester bond formed! ' + item.base + ' connected to leading strand');
                                    } else {
                                        showError('Nucleotide ' + item.base + ' added to leading strand');
                                    }
                                    
                                    gameState.polymerasePositions.leading = clickPos.index - 1;
                                    const leadingPolymerase = gameState.placedEnzymes.find(e => 
                                        e.type === 'polymerase' && e.y < canvas.height / 2);
                                    if (leadingPolymerase) {
                                        const baseWidth = Math.min(26, (canvas.width - 200) / gameState.dnaSequence.length);
                                        const startX = canvas.width / 2 - (gameState.dnaSequence.length * baseWidth / 2);
                                        leadingPolymerase.x = startX + Math.max(0, clickPos.index - 1) * baseWidth;
                                    }
                                }
                                
                                if (clickPos.strand === 'lagging') {
                                    if (clickPos.index > 0 && gameState.dnaStrands.laggingNew[clickPos.index - 1]) {
                                        addBondAnimation(clickPos.index - 1, 'lagging');
                                        showError('Phosphodiester bond formed! ' + item.base + ' connected to lagging strand');
                                    } else {
                                        showError('Nucleotide ' + item.base + ' added to lagging strand');
                                    }
                                    
                                    const laggingPolymerase = gameState.placedEnzymes.find(e => 
                                        e.type === 'polymerase' && e.y > canvas.height / 2);
                                    
                                    if (laggingPolymerase) {
                                        const baseWidth = Math.min(26, (canvas.width - 200) / gameState.dnaSequence.length);
                                        const startX = canvas.width / 2 - (gameState.dnaSequence.length * baseWidth / 2);
                                        
                                        let nextPosition = clickPos.index + 1;
                                        const currentFragment = gameState.laggingFragments[gameState.currentFragment];
                                        if (nextPosition <= currentFragment.end) {
                                            gameState.polymerasePositions.lagging = nextPosition;
                                            laggingPolymerase.x = startX + nextPosition * baseWidth;
                                        }
                                    }
                                    
                                    // Handle fragment completion and transitions
                                    if (gameState.currentFragment === 0 && clickPos.index >= 4 && clickPos.index <= 10) {
                                        const fragment = gameState.laggingFragments[0];
                                        fragment.nucleotidesAdded++;
                                        
                                        if (clickPos.index === 10 || fragment.nucleotidesAdded >= 7) {
                                            fragment.completed = true;
                                            setTimeout(() => {
                                                showError('Fragment 1 complete! Adding primer for Fragment 2...');
                                                gameState.laggingFragments[1].primerAdded = true;
                                                gameState.currentFragment = 1;
                                                setTimeout(() => {
                                                    showError('Fragment 2 primer added! DNA Polymerase III moving to new position...');
                                                    gameState.polymerasePositions.lagging = 15;
                                                    if (laggingPolymerase) {
                                                        const baseWidth = Math.min(26, (canvas.width - 200) / gameState.dnaSequence.length);
                                                        const startX = canvas.width / 2 - (gameState.dnaSequence.length * baseWidth / 2);
                                                        laggingPolymerase.x = startX + 15 * baseWidth;
                                                    }
                                                }, 3000);
                                            }, 2000);
                                        }
                                    } else if (gameState.currentFragment === 1 && clickPos.index >= 15 && clickPos.index <= 21) {
                                        const fragment = gameState.laggingFragments[1];
                                        fragment.nucleotidesAdded++;
                                        
                                        if (clickPos.index === 21 || fragment.nucleotidesAdded >= 7) {
                                            fragment.completed = true;
                                            setTimeout(() => {
                                                showError('Fragment 2 complete! Adding primer for Fragment 3...');
                                                gameState.laggingFragments[2].primerAdded = true;
                                                gameState.currentFragment = 2;
                                                setTimeout(() => {
                                                    showError('Fragment 3 primer added! DNA Polymerase III moving to final position...');
                                                    gameState.polymerasePositions.lagging = 26;
                                                    if (laggingPolymerase) {
                                                        const baseWidth = Math.min(26, (canvas.width - 200) / gameState.dnaSequence.length);
                                                        const startX = canvas.width / 2 - (gameState.dnaSequence.length * baseWidth / 2);
                                                        laggingPolymerase.x = startX + 26 * baseWidth;
                                                    }
                                                }, 3000);
                                            }, 2000);
                                        }
                                    } else if (gameState.currentFragment === 2 && clickPos.index >= 26 && clickPos.index <= 29) {
                                        const fragment = gameState.laggingFragments[2];
                                        fragment.nucleotidesAdded++;
                                        if (fragment.nucleotidesAdded >= 4) {
                                            fragment.completed = true;
                                            showError('Final fragment complete! All Okazaki fragments synthesized.');
                                        }
                                    }
                                }
                                
                                const leadingComplete = gameState.nucleotideCount.leading >= gameState.dnaSequence.length - 4;
                                const laggingComplete = gameState.nucleotideCount.lagging >= 18;
                                if (leadingComplete && laggingComplete) {
                                    setTimeout(() => {
                                        showError('Both strands complete! Ready for DNA Polymerase I to replace RNA primers!');
                                        updateCurrentStepInstruction();
                                    }, 2500);
                                } else {
                                    updateCurrentStepInstruction();
                                }
                                
                            } else {
                                const originalBase = clickPos.strand === 'leading' ? 
                                    gameState.dnaStrands.leading[clickPos.index] : 
                                    gameState.dnaStrands.lagging[clickPos.index];
                                const expectedBase = getComplement(originalBase);
                                showError('WRONG BASE PAIR! Template ' + originalBase + ' pairs with ' + expectedBase + ', NOT ' + item.base + '. Follow base pairing rules!');
                            }
                        } else {
                            showError('Position already filled!');
                        }
                    } else if (!gameState.polymeraseActive) {
                        showError('DNA Polymerase III must be active first!');
                    } else if (gameState.ligaseProcessing) {
                        showError('DNA Ligase is currently joining fragments automatically!');
                    } else if (!clickPos) {
                        showError('Drop nucleotide on a valid position!');
                    }
                }
                
                gameState.isDragging = false;
                gameState.draggedItem = null;
                
                document.querySelectorAll('.dragging').forEach(el => {
                    el.classList.remove('dragging');
                });
            }
        });

        document.querySelectorAll('.tool-item').forEach(item => {
            item.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const enzymeType = item.dataset.enzyme;
                
                gameState.isDragging = true;
                gameState.draggedItem = {
                    type: 'enzyme',
                    enzyme: enzymeType,
                    x: 0,
                    y: 0
                };
                
                item.classList.add('dragging');
            });
        });

        document.querySelectorAll('.nucleotide-item').forEach(item => {
            item.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const baseType = item.dataset.base;
                
                gameState.isDragging = true;
                gameState.draggedItem = {
                    type: 'nucleotide',
                    base: baseType,
                    x: 0,
                    y: 0
                };
                
                item.classList.add('dragging');
            });
        });

        document.getElementById('dnaInput').addEventListener('input', (e) => {
            let value = e.target.value.toUpperCase().replace(/[^ATGC]/g, '');
            if (value.length !== 30) {
                const bases = ['A', 'T', 'G', 'C'];
                if (value.length < 30) {
                    while (value.length < 30) {
                        value += bases[Math.floor(Math.random() * bases.length)];
                    }
                } else {
                    value = value.substring(0, 30);
                }
            }
            e.target.value = value;
            gameState.dnaSequence = value;
            gameState.originalSequence = value;
            updateDNADisplays();
        });

        document.getElementById('generateBtn').addEventListener('click', () => {
            const newSequence = generateRandomSequence();
            document.getElementById('dnaInput').value = newSequence;
            gameState.dnaSequence = newSequence;
            gameState.originalSequence = newSequence;
            updateDNADisplays();
            initSimulation();
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            gameState.running = true;
            document.getElementById('startBtn').classList.add('active');
            updateCurrentStepInstruction();
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            gameState.running = false;
            document.getElementById('startBtn').classList.remove('active');
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            gameState.running = false;
            gameState.dnaSequence = gameState.originalSequence;
            document.getElementById('startBtn').classList.remove('active');
            document.getElementById('completionOverlay').classList.remove('show');
            initSimulation();
        });

        document.getElementById('completionOverlay').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('completionOverlay').classList.remove('show');
            gameState.running = false;
            gameState.dnaSequence = gameState.originalSequence;
            document.getElementById('startBtn').classList.remove('active');
            initSimulation();
            setTimeout(() => {
                showError('New simulation ready! Follow the steps to replicate DNA again.');
            }, 500);
        });

        function initSimulation() {
            updateDNADisplays();
            updateStatusDisplay();
            
            gameState.placedEnzymes = [];
            gameState.helicaseActive = false;
            gameState.primaseActive = false;
            gameState.primaseCount = 0;
            gameState.polymeraseActive = false;
            gameState.polymeraseCount = 0;
            gameState.pol1Active = false;
            gameState.pol1Count = 0;
            gameState.ligaseActive = false;
            gameState.ligaseProcessing = false;
            gameState.strandSeparation = 0;
            gameState.nucleotidePositions = [];
            gameState.nucleotideCount = { leading: 0, lagging: 0 };
            gameState.rnaPrimers = { leading: false, lagging: false };
            gameState.bondAnimations = [];
            gameState.currentFragment = 0;
            gameState.ligaseTimer = 0;
            gameState.ligaseGapIndex = 0;
            gameState.gapsFixed = [];
            gameState.allGapsFixed = false;
            gameState.polymerasePositions = {
                leading: -1,
                lagging: -1
            };
            
            gameState.laggingFragments = [
                { start: 0, end: 10, primerAdded: false, nucleotidesAdded: 0, completed: false },
                { start: 11, end: 21, primerAdded: false, nucleotidesAdded: 0, completed: false },
                { start: 22, end: 29, primerAdded: false, nucleotidesAdded: 0, completed: false }
            ];
            
            gameState.dnaCenter = {
                x: canvas.width / 2,
                y: canvas.height / 2
            };
        }

        initSimulation();
        render();
    </script>
</body>
</html>
